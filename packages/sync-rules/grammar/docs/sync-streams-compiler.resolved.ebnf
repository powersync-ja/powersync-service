/* Top-level stream query form: streams.<name>.query / streams.<name>.queries[] */

CompilerStreamQuery ::= "SELECT" ResultColumn ("," ResultColumn)* "FROM" FromSource ("," FromSource | JoinClause)* ("WHERE" WhereExpr)?

/* Supports wildcard, table wildcard, or scalar expression columns */

ResultColumn ::= "*" | Identifier ("." Identifier)? "." "*" | ScalarExpr ("AS" Identifier)?

FromSource ::= TableValuedSource | SubquerySource | TableSource

/* Table and table-valued sources may be unaliased or AS-aliased */

TableSource ::= Identifier ("." Identifier)? "AS" Identifier | Identifier ("." Identifier)?

TableValuedSource ::= Identifier "(" (ScalarExpr ("," ScalarExpr)*)? ")" "AS" Identifier | Identifier "(" (ScalarExpr ("," ScalarExpr)*)? ")"

/* Subqueries require an alias; optional column-name list is supported */

SubquerySource ::= "(" CompilerSubquery ")" "AS" Identifier ("(" Identifier ("," Identifier)* ")")?

JoinClause ::= "INNER"? "JOIN" FromSource ("ON" WhereExpr)?

WhereExpr ::= "NOT"? (Predicate | "(" WhereExpr ")") ("AND" "NOT"? (Predicate | "(" WhereExpr ")"))* ("OR" "NOT"? (Predicate | "(" WhereExpr ")") ("AND" "NOT"? (Predicate | "(" WhereExpr ")"))*)*

Predicate ::= ScalarExpr PredicateTail | ScalarExpr

/* Includes IN/NOT IN, overlap, null checks, and BETWEEN */

PredicateTail ::= "=" ScalarExpr | "IN" InSource | "NOT" "IN" InSource | "&&" InSource | "IS" "NOT"? "NULL" | "NOT"? "BETWEEN" ScalarExpr "AND" ScalarExpr

InSource ::= "(" CompilerSubquery ")" | Identifier | ScalarExpr

/* Scalar expression subset lowered by compiler/sqlite.ts */

ScalarExpr ::= PrimaryTerm (("->>" | "->") (StringLiteral | IntegerLiteral))* (("=" | "!=" | "<" | ">" | "<=" | ">=" | "+" | "-" | "*" | "/" | "%" | "||" | "|" | "&" | "<<" | ">>") PrimaryTerm (("->>" | "->") (StringLiteral | IntegerLiteral))*)*

PrimaryTerm ::= (StringLiteral | NumericLiteral | "TRUE" | "FALSE" | "NULL") | CaseExpr | CastExpr | FunctionCall | Identifier ("." Identifier)? | "(" ScalarExpr ")"

/* CASE expression subset supported by compiler parser */

CaseExpr ::= SearchedCaseExpr | SimpleCaseExpr

SearchedCaseExpr ::= "CASE" "WHEN" CaseCondition "THEN" ScalarExpr ("WHEN" CaseCondition "THEN" ScalarExpr)* ("ELSE" ScalarExpr)? "END"

CaseCondition ::= "NOT"? (Predicate | "(" WhereExpr ")") ("AND" "NOT"? (Predicate | "(" WhereExpr ")"))* ("OR" "NOT"? (Predicate | "(" WhereExpr ")") ("AND" "NOT"? (Predicate | "(" WhereExpr ")"))*)*

SimpleCaseExpr ::= "CASE" ScalarExpr "WHEN" ScalarExpr "THEN" ScalarExpr ("WHEN" ScalarExpr "THEN" ScalarExpr)* ("ELSE" ScalarExpr)? "END"

CastExpr ::= "CAST" "(" ScalarExpr "AS" ("TEXT" | "INTEGER" | "REAL" | "NUMERIC" | "BLOB") ")"

FunctionCall ::= (Identifier ".")? Identifier "(" (ScalarExpr ("," ScalarExpr)*)? ")"

CompilerSubquery ::= "SELECT" ResultColumn ("," ResultColumn)* "FROM" FromSource ("," FromSource | JoinClause)* ("WHERE" WhereExpr)?

/* CTE bodies (streams.<name>.with.<cte_name>) disallow wildcard columns by using ScalarExpr columns only */

CompilerCteSubquery ::= "SELECT" ScalarExpr ("AS" Identifier)? ("," ScalarExpr ("AS" Identifier)?)* "FROM" FromSource ("," FromSource | JoinClause)* ("WHERE" WhereExpr)?

/* Identifiers are matched after SQL normalization to uppercase in tests. */

Identifier ::= [A-Z_] ([A-Z_0-9])*

StringLiteral ::= "'" ([\x20-\x26] | [\x28-\x7E])* "'"

IntegerLiteral ::= ([0-9])+

NumericLiteral ::= ([0-9])+ ("." ([0-9])+)?
