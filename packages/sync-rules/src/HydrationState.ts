import { BucketDataSource, BucketParameterLookupSourceDefinition } from './BucketSource.js';

export interface BucketDataScope {
  /** The prefix is the bucket name before the parameters. */
  bucketPrefix: string;
}

export interface ParameterLookupScope {
  /** The lookup name + queryid is used to reference the parameter lookup record. */
  lookupName: string;
  queryId: string;
}

/**
 * Hydration state information for a source.
 *
 * This is what keeps track of bucket name and parameter lookup mappings for hydration. This can be used
 * both to re-use mappings across hydrations of different sync rule versions, or to generate new mappings.
 */
export interface HydrationState<
  T extends BucketDataScope = BucketDataScope,
  U extends ParameterLookupScope = ParameterLookupScope
> {
  /**
   * Given a bucket data source definition, get the bucket prefix to use for it.
   */
  getBucketSourceScope(source: BucketDataSource): T;

  /**
   * Given a bucket parameter lookup definition, get the persistence name to use.
   */
  getParameterLookupScope(source: BucketParameterLookupSourceDefinition): U;
}

/**
 * This represents hydration state that performs no transformations.
 *
 * This is the legacy default behavior with no bucket versioning.
 */
export const DEFAULT_HYDRATION_STATE: HydrationState = {
  getBucketSourceScope(source: BucketDataSource) {
    return {
      bucketPrefix: source.defaultBucketPrefix
    };
  },
  getParameterLookupScope(source) {
    return source.defaultLookupScope;
  }
};

/**
 * Transforms bucket ids generated when evaluating the row by e.g. encoding version information.
 *
 * Because buckets are recreated on a sync rule redeploy, it makes sense to use different bucket ids (otherwise, clients
 * may run into checksum errors causing a sync to take longer than necessary or breaking progress).
 *
 * So, this transformer receives the original bucket id as generated by defined sync rules, and can prepend a version
 * identifier.
 *
 * Note that this transformation has not been present in older versions of the sync service. To preserve backwards
 * compatibility, sync rules will not use this without an opt-in.
 */
export function versionedHydrationState(version: number): HydrationState {
  return {
    getBucketSourceScope(source: BucketDataSource): BucketDataScope {
      return {
        bucketPrefix: `${version}#${source.defaultBucketPrefix}`
      };
    },

    getParameterLookupScope(source: BucketParameterLookupSourceDefinition): ParameterLookupScope {
      // No transformations applied here
      return source.defaultLookupScope;
    }
  };
}
